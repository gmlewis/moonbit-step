// Generated using `moon info`, DON'T EDIT IT
package "gmlewis/step/cad"

import {
  "gmlewis/fonts",
  "gmlewis/step",
  "gmlewis/step/repository",
}

// Values
pub fn compile_calibration_chamfer_block(StepContext, SceneNode, CalibrationChamferBlock, reverse? : Bool) -> Array[@step.Ref]

pub fn compile_cuboid(StepContext, SceneNode, Cuboid, reverse? : Bool) -> Array[@step.Ref]

pub fn compile_extruded_profile(StepContext, SceneNode, ExtrudedProfile, reverse? : Bool) -> Array[@step.Ref]

pub fn cycle_area_3d(Array[(Double, Double, Double)], Array[Int]) -> (Double, Double, Double)

pub fn difference(SceneNode, Array[SceneNode], name? : String) -> SceneNode

pub fn fmt_double(Double, Double?) -> String

pub fn force_ccw(Array[(Double, Double)]) -> Array[(Double, Double)]

pub fn force_cw(Array[(Double, Double)]) -> Array[(Double, Double)]

pub fn helix_path(pos? : (Double, Double, Double), size_per_turn? : (Double, Double, Double), num_turns? : Double, num_segs_per_turn? : Int, start_angle? : Double, clockwise? : Bool) -> SweepPath

pub fn is_point_in_polygon((Double, Double), Array[(Double, Double)]) -> Bool

pub async fn load_font(String) -> @fonts.Font raise LoaderError

pub fn matrix_to_euler(Matrix3x3) -> (Double, Double, Double)

pub fn polygon_area_2d(Array[(Double, Double)]) -> Double

pub fn rotate_point((Double, Double, Double), Double, Double, Double) -> (Double, Double, Double)

pub fn snap_double(Double, Double?) -> Double

pub fn text_at(String, Double, Double, Double, font~ : @fonts.Font, font_size? : Double, max_width? : Double, emboss_depth? : Double, rx? : Double, ry? : Double, rz? : Double, segments? : Int) -> Array[SceneNode]

pub fn translate_pts(Array[(Double, Double)], Double, Double) -> Array[(Double, Double)]

pub fn tube(Double, Double, Double, segments? : Int) -> Shape

pub fn union_all(Array[SceneNode], name? : String) -> SceneNode

pub async fn write_text_file(String, String?) -> Unit

// Errors
pub suberror LoaderError {
  LoaderError(String)
}
pub impl Eq for LoaderError
pub impl Show for LoaderError

// Types and methods
pub struct BezierAnchor {
  position : (Double, Double)
  handle_in : (Double, Double)
  handle_out : (Double, Double)
}

pub struct BezierPath {
  anchors : Array[BezierAnchor]
  closed : Bool
  clear : Bool
}

pub struct BooleanDifference {
  base : SceneNode
  cutters : Array[SceneNode]
}

pub struct BooleanUnion {
  nodes : Array[SceneNode]
}

pub struct CalibrationChamferBlock {
  length_mm : Double
  width_mm : Double
  height_mm : Double
  chamfer_size_mm : Double
  fillet_radius_mm : Double
  fillet_segments : Int
}
pub fn CalibrationChamferBlock::new(Double, Double, Double, chamfer_size_mm? : Double, fillet_radius_mm? : Double, fillet_segments? : Int) -> Shape

pub struct Cuboid {
  sx : Double
  sy : Double
  sz : Double
}
pub fn Cuboid::new(Double, Double, Double) -> Shape

pub struct Design {
  nodes : Array[SceneNode]
  next_solid_id : Int
  name : String
  description : String
  snapping : Double?
}
pub fn Design::add(Self, SceneNode) -> Self
pub fn Design::add_iter(Self, Iter[SceneNode]) -> Self
pub fn Design::add_text_on_face(Self, SceneNode, String, Face, @fonts.Font, font_size? : Double, emboss_depth? : Double, offset_x? : Double, offset_y? : Double, rotation? : Double, margin? : Double, color? : Rgb, emboss? : Bool, segments? : Int) -> Self
pub fn Design::compile(Self) -> @repository.Repository
pub async fn Design::create_blender_file(Self, String, keep_modifiers? : Bool, segments? : Int) -> Unit
pub fn Design::new(name? : String, description? : String, snapping? : Double) -> Self
pub fn Design::rotate_x(Self, Double) -> Self
pub fn Design::rotate_y(Self, Double) -> Self
pub fn Design::rotate_z(Self, Double) -> Self
pub fn Design::to_blender_python(Self, segments? : Int, keep_modifiers? : Bool) -> String
pub fn Design::to_step_file(Self) -> String
pub fn Design::to_string(Self) -> String
pub fn Design::translate(Self, x? : Double, y? : Double, z? : Double) -> Self
pub async fn Design::write_blender_python(Self, String?, segments? : Int, keep_modifiers? : Bool) -> Unit
pub async fn Design::write_step(Self, String?) -> Unit
pub async fn Design::write_step_file(Self, String?) -> Unit

pub(all) struct EdgeInfo {
  start : Int
  end : Int
  edge : @step.Ref
}

pub struct ExtrudedBezierProfile {
  paths : Array[BezierPath]
  height_mm : Double
}
pub fn ExtrudedBezierProfile::new(Array[BezierPath], Double) -> Shape

pub struct ExtrudedProfile {
  profile : Profile2D
  height_mm : Double
}
pub fn ExtrudedProfile::new(Array[(Double, Double)], Double, holes? : Array[Array[(Double, Double)]]) -> Shape

pub(all) enum Face {
  Top
  Bottom
  Front
  Back
  Left
  Right
}

pub(all) struct Matrix3x3 {
  m00 : Double
  m01 : Double
  m02 : Double
  m10 : Double
  m11 : Double
  m12 : Double
  m20 : Double
  m21 : Double
  m22 : Double
}

pub struct Profile2D {
  outer : Array[(Double, Double)]
  holes : Array[Array[(Double, Double)]]
}
pub fn Profile2D::add_hole(Self, Array[(Double, Double)]) -> Self
pub fn Profile2D::add_holes_at(Self, Array[(Double, Double)], Array[(Double, Double)]) -> Self
pub fn Profile2D::arc(Double, Double, Double, segments? : Int) -> Array[(Double, Double)]
pub fn Profile2D::centered_rect(Double, Double) -> Array[(Double, Double)]
pub fn Profile2D::circle(Double, segments? : Int) -> Array[(Double, Double)]
pub fn Profile2D::ellipse(Double, Double, segments? : Int) -> Array[(Double, Double)]
pub fn Profile2D::new(Array[(Double, Double)]) -> Self
pub fn Profile2D::polygon(Int, Double, rotation? : Double) -> Array[(Double, Double)]
pub fn Profile2D::rect(Double, Double) -> Array[(Double, Double)]
pub fn Profile2D::rounded_rect(Double, Double, Double, segments? : Int) -> Array[(Double, Double)]

pub struct Rgb {
  r : Double
  g : Double
  b : Double
}
pub fn Rgb::black() -> Self
pub fn Rgb::blue() -> Self
pub fn Rgb::cyan() -> Self
pub fn Rgb::green() -> Self
pub fn Rgb::grey() -> Self
pub fn Rgb::magenta() -> Self
pub fn Rgb::new(Double, Double, Double) -> Self
pub fn Rgb::orange() -> Self
pub fn Rgb::purple() -> Self
pub fn Rgb::red() -> Self
pub fn Rgb::white() -> Self

pub struct SceneNode {
  shape : Shape
  name : String
  color : Rgb
  tx : Double
  ty : Double
  tz : Double
  rx : Double
  ry : Double
  rz : Double
}
pub fn SceneNode::bounding_box(Self) -> (Double, Double, Double, Double, Double, Double)
pub fn SceneNode::repeat_at(Self, Array[(Double, Double, Double)]) -> Array[Self]
pub fn SceneNode::rotate_x(Self, Double) -> Self
pub fn SceneNode::rotate_y(Self, Double) -> Self
pub fn SceneNode::rotate_z(Self, Double) -> Self
pub fn SceneNode::translate(Self, x? : Double, y? : Double, z? : Double) -> Self
pub fn SceneNode::with_color(Self, Rgb) -> Self
pub fn SceneNode::with_name(Self, String) -> Self

pub enum Shape {
  Cuboid(Cuboid)
  CalibrationChamferBlock(CalibrationChamferBlock)
  ExtrudedProfile(ExtrudedProfile)
  ExtrudedBezierProfile(ExtrudedBezierProfile)
  SweptProfile(SweptProfile)
  Union(BooleanUnion)
  Difference(BooleanDifference)
}
pub fn Shape::bounding_box(Self) -> (Double, Double, Double, Double, Double, Double)
pub fn Shape::with_color(Self, Rgb) -> SceneNode
pub fn Shape::with_name(Self, String) -> SceneNode

pub struct StepContext {
  mut repo : @repository.Repository
  mut length_unit_id : @step.EntityId
  mut plane_angle_unit_id : @step.EntityId
  mut solid_angle_unit_id : @step.EntityId
  mut uncertainty_id : @step.EntityId
  mut repo_ctx_id : @step.EntityId
  snapping : Double?
  directions : Map[String, @step.Ref]
  vectors : Map[String, @step.Ref]
  cartesian_points : Map[String, @step.Ref]
  vertex_points : Map[Int, @step.Ref]
  lines : Map[String, @step.Ref]
  edge_curves : Map[String, @step.Ref]
  axis2_placements : Map[String, @step.Ref]
  oriented_edges : Map[String, @step.Ref]
  edge_loops : Map[String, @step.Ref]
  face_bounds : Map[String, @step.Ref]
  advanced_faces : Map[String, @step.Ref]
}
pub fn StepContext::add_product_definition(Self, String) -> @step.Ref
pub fn StepContext::advanced_face(Self, Array[@step.Ref], @step.Ref, Bool) -> @step.Ref
pub fn StepContext::axis2_placement_3d(Self, @step.Ref, @step.Ref, @step.Ref) -> @step.Ref
pub fn StepContext::cartesian_point(Self, Double, Double, Double) -> @step.Ref
pub fn StepContext::direction(Self, Double, Double, Double) -> @step.Ref
pub fn StepContext::edge_curve(Self, @step.Ref, @step.Ref, @step.Ref, Bool) -> @step.Ref
pub fn StepContext::edge_loop(Self, Array[@step.Ref]) -> @step.Ref
pub fn StepContext::face_bound(Self, @step.Ref, Bool) -> @step.Ref
pub fn StepContext::face_outer_bound(Self, @step.Ref, Bool) -> @step.Ref
pub fn StepContext::init_standard_context(Self, String) -> Unit
pub fn StepContext::line(Self, @step.Ref, @step.Ref) -> @step.Ref
pub fn StepContext::new(snapping? : Double) -> Self
pub fn StepContext::oriented_edge(Self, @step.Ref, Bool) -> @step.Ref
pub fn StepContext::vector(Self, @step.Ref, Double) -> @step.Ref
pub fn StepContext::vertex_point(Self, @step.Ref) -> @step.Ref

pub(all) struct SweepPath {
  points : Array[(Double, Double, Double)]
  normals : Array[(Double, Double, Double)]
  tangents : Array[(Double, Double, Double)]
}

pub(all) struct SweepProfile {
  center : (Double, Double, Double)
  vertices : Array[(Double, Double, Double)]
  normal_dir : (Double, Double, Double)
  right_dir : (Double, Double, Double)
}
pub fn SweepProfile::new(Array[(Double, Double, Double)], center? : (Double, Double, Double), normal_dir? : (Double, Double, Double), right_dir? : (Double, Double, Double)) -> Self

pub struct SweptProfile {
  path : SweepPath
  profile : SweepProfile
  make_start_cap : Bool
  make_end_cap : Bool
}
pub fn SweptProfile::new(path~ : SweepPath, profile~ : SweepProfile, make_start_cap? : Bool, make_end_cap? : Bool) -> Shape

// Type aliases
pub using @fonts {type Font}

pub type Vec2 = (Double, Double)

pub type Vec3 = (Double, Double, Double)

// Traits

