// Generated using `moon info`, DON'T EDIT IT
package "gmlewis/step/cad"

import(
  "gmlewis/fonts"
  "gmlewis/step"
  "gmlewis/step/repository"
)

// Values
pub fn compile_calibration_chamfer_block(StepContext, SceneNode, CalibrationChamferBlock) -> @step.Ref

pub fn compile_cuboid(StepContext, SceneNode, Cuboid) -> @step.Ref

pub fn compile_extruded_profile(StepContext, SceneNode, ExtrudedProfile) -> @step.Ref

pub fn cycle_area_3d(Array[(Double, Double, Double)], Array[Int]) -> (Double, Double, Double)

pub fn force_ccw(Array[(Double, Double)]) -> Array[(Double, Double)]

pub fn force_cw(Array[(Double, Double)]) -> Array[(Double, Double)]

pub fn helix_path(pos? : (Double, Double, Double), size_per_turn? : (Double, Double, Double), num_turns? : Double, num_segs_per_turn? : Int, start_angle? : Double, clockwise? : Bool) -> SweepPath

pub fn is_point_in_polygon((Double, Double), Array[(Double, Double)]) -> Bool

pub fn matrix_to_euler(Matrix3x3) -> (Double, Double, Double)

pub fn polygon_area_2d(Array[(Double, Double)]) -> Double

pub fn rotate_point((Double, Double, Double), Double, Double, Double) -> (Double, Double, Double)

pub fn text_at(String, Double, Double, Double, font~ : @fonts.Font, font_size? : Double, max_width? : Double, emboss_depth? : Double, rx? : Double, ry? : Double, rz? : Double) -> Array[SceneNode]

pub fn translate_pts(Array[(Double, Double)], Double, Double) -> Array[(Double, Double)]

pub fn tube(Double, Double, Double, segments? : Int) -> Shape

pub async fn write_step_text(String, String?) -> Unit

// Errors

// Types and methods
pub struct CalibrationChamferBlock {
  length_mm : Double
  width_mm : Double
  height_mm : Double
  chamfer_size_mm : Double
  fillet_radius_mm : Double
  fillet_segments : Int
}
pub fn CalibrationChamferBlock::new(Double, Double, Double, chamfer_size_mm? : Double, fillet_radius_mm? : Double, fillet_segments? : Int) -> Shape

pub struct Cuboid {
  sx : Double
  sy : Double
  sz : Double
}
pub fn Cuboid::new(Double, Double, Double) -> Shape

pub struct Design {
  nodes : Array[SceneNode]
  next_solid_id : Int
  name : String
  description : String
}
pub fn Design::add(Self, SceneNode) -> Self
pub fn Design::add_iter(Self, Iter[SceneNode]) -> Self
pub fn Design::add_text_on_face(Self, SceneNode, String, Face, @fonts.Font, font_size? : Double, emboss_depth? : Double, offset_x? : Double, offset_y? : Double, rotation? : Double, margin? : Double, color? : Rgb) -> Self
pub fn Design::compile(Self) -> @repository.Repository
pub fn Design::new(name? : String, description? : String) -> Self
pub fn Design::rotate_x(Self, Double) -> Self
pub fn Design::rotate_y(Self, Double) -> Self
pub fn Design::rotate_z(Self, Double) -> Self
pub fn Design::to_step_file(Self) -> String
pub fn Design::to_string(Self) -> String
pub fn Design::translate(Self, x? : Double, y? : Double, z? : Double) -> Self
pub async fn Design::write_step(Self, String?) -> Unit
pub async fn Design::write_step_file(Self, String?) -> Unit

pub(all) struct EdgeInfo {
  start : Int
  end : Int
  edge : @step.Ref
}

pub struct ExtrudedProfile {
  profile : Profile2D
  height_mm : Double
}
pub fn ExtrudedProfile::new(Array[(Double, Double)], Double, holes? : Array[Array[(Double, Double)]]) -> Shape

pub(all) enum Face {
  Top
  Bottom
  Front
  Back
  Left
  Right
}

pub(all) struct Matrix3x3 {
  m00 : Double
  m01 : Double
  m02 : Double
  m10 : Double
  m11 : Double
  m12 : Double
  m20 : Double
  m21 : Double
  m22 : Double
}

pub struct Profile2D {
  outer : Array[(Double, Double)]
  holes : Array[Array[(Double, Double)]]
}
pub fn Profile2D::add_hole(Self, Array[(Double, Double)]) -> Self
pub fn Profile2D::add_holes_at(Self, Array[(Double, Double)], Array[(Double, Double)]) -> Self
pub fn Profile2D::arc(Double, Double, Double, segments? : Int) -> Array[(Double, Double)]
pub fn Profile2D::centered_rect(Double, Double) -> Array[(Double, Double)]
pub fn Profile2D::circle(Double, segments? : Int) -> Array[(Double, Double)]
pub fn Profile2D::ellipse(Double, Double, segments? : Int) -> Array[(Double, Double)]
pub fn Profile2D::new(Array[(Double, Double)]) -> Self
pub fn Profile2D::polygon(Int, Double, rotation? : Double) -> Array[(Double, Double)]
pub fn Profile2D::rect(Double, Double) -> Array[(Double, Double)]
pub fn Profile2D::rounded_rect(Double, Double, Double, segments? : Int) -> Array[(Double, Double)]

pub struct Rgb {
  r : Double
  g : Double
  b : Double
}
pub fn Rgb::black() -> Self
pub fn Rgb::blue() -> Self
pub fn Rgb::cyan() -> Self
pub fn Rgb::green() -> Self
pub fn Rgb::grey() -> Self
pub fn Rgb::magenta() -> Self
pub fn Rgb::new(Double, Double, Double) -> Self
pub fn Rgb::orange() -> Self
pub fn Rgb::purple() -> Self
pub fn Rgb::red() -> Self
pub fn Rgb::white() -> Self

pub struct SceneNode {
  shape : Shape
  name : String
  color : Rgb
  tx : Double
  ty : Double
  tz : Double
  rx : Double
  ry : Double
  rz : Double
}
pub fn SceneNode::repeat_at(Self, Array[(Double, Double, Double)]) -> Array[Self]
pub fn SceneNode::rotate_x(Self, Double) -> Self
pub fn SceneNode::rotate_y(Self, Double) -> Self
pub fn SceneNode::rotate_z(Self, Double) -> Self
pub fn SceneNode::translate(Self, x? : Double, y? : Double, z? : Double) -> Self
pub fn SceneNode::with_color(Self, Rgb) -> Self
pub fn SceneNode::with_name(Self, String) -> Self

pub enum Shape {
  Cuboid(Cuboid)
  CalibrationChamferBlock(CalibrationChamferBlock)
  ExtrudedProfile(ExtrudedProfile)
  SweptProfile(SweptProfile)
}
pub fn Shape::with_color(Self, Rgb) -> SceneNode
pub fn Shape::with_name(Self, String) -> SceneNode

pub struct StepContext {
  mut repo : @repository.Repository
  mut length_unit_id : @step.EntityId
  mut plane_angle_unit_id : @step.EntityId
  mut solid_angle_unit_id : @step.EntityId
  mut uncertainty_id : @step.EntityId
  mut repo_ctx_id : @step.EntityId
  directions : Map[String, @step.Ref]
  vectors : Map[String, @step.Ref]
  cartesian_points : Map[String, @step.Ref]
  vertex_points : Map[Int, @step.Ref]
  lines : Map[String, @step.Ref]
  edge_curves : Map[String, @step.Ref]
}
pub fn StepContext::add_product_definition(Self, String) -> @step.Ref
pub fn StepContext::cartesian_point(Self, Double, Double, Double) -> @step.Ref
pub fn StepContext::direction(Self, Double, Double, Double) -> @step.Ref
pub fn StepContext::edge_curve(Self, @step.Ref, @step.Ref, @step.Ref, Bool) -> @step.Ref
pub fn StepContext::init_standard_context(Self, String) -> Unit
pub fn StepContext::line(Self, @step.Ref, @step.Ref) -> @step.Ref
pub fn StepContext::new() -> Self
pub fn StepContext::vector(Self, @step.Ref, Double) -> @step.Ref
pub fn StepContext::vertex_point(Self, @step.Ref) -> @step.Ref

pub(all) struct SweepPath {
  points : Array[(Double, Double, Double)]
  normals : Array[(Double, Double, Double)]
  tangents : Array[(Double, Double, Double)]
}

pub(all) struct SweepProfile {
  center : (Double, Double, Double)
  vertices : Array[(Double, Double, Double)]
  normal_dir : (Double, Double, Double)
  right_dir : (Double, Double, Double)
}
pub fn SweepProfile::new(Array[(Double, Double, Double)], center? : (Double, Double, Double), normal_dir? : (Double, Double, Double), right_dir? : (Double, Double, Double)) -> Self

pub struct SweptProfile {
  path : SweepPath
  profile : SweepProfile
}
pub fn SweptProfile::new(path~ : SweepPath, profile~ : SweepProfile) -> Shape

// Type aliases

// Traits

