///|
// Builder-style CAD helpers.
//
// The goal is a pleasant authoring UX for examples: build a model using a few
// high-level calls, then serialize to a valid STEP Part 21 file.

///|
pub struct Design {
  nodes : Array[SceneNode]
  next_solid_id : Int
  name : String
  description : String
  snapping : Double?
}

///|
pub fn Design::new(
  name? : String = "model",
  description? : String = "generated by gmlewis/step/cad",
  snapping? : Double,
) -> Design {
  Design::{ nodes: [], next_solid_id: 1, name, description, snapping }
}

///|
fn compile_node_geometry_and_styling(
  ctx : StepContext,
  node : SceneNode,
  solid_ref : @step.Ref,
) -> Unit {
  // Presentation styling
  let rgb = @presentation.ColorRgb::new(
    node.name,
    node.color.r,
    node.color.g,
    node.color.b,
  )
  let rgb_ref = ctx.add(@repository.any_entity_color_rgb(rgb))
  let fas_col = @presentation.FillAreaStyleColor::new("", rgb_ref)
  let fas_col_ref = ctx.add(
    @repository.any_entity_fill_area_style_color(fas_col),
  )
  let fas = @presentation.FillAreaStyle::new("", [fas_col_ref])
  let fas_ref = ctx.add(@repository.any_entity_fill_area_style(fas))
  let ssfa = @presentation.SurfaceStyleFillArea::new(fas_ref)
  let ssfa_ref = ctx.add(@repository.any_entity_surface_style_fill_area(ssfa))
  let sss = @presentation.SurfaceSideStyle::new("", [ssfa_ref])
  let sss_ref = ctx.add(@repository.any_entity_surface_side_style(sss))
  let ssu = @presentation.SurfaceStyleUsage::new(".BOTH.", sss_ref)
  let ssu_ref = ctx.add(@repository.any_entity_surface_style_usage(ssu))
  let psa = @presentation.PresentationStyleAssignment::new([ssu_ref])
  let psa_ref = ctx.add(
    @repository.any_entity_presentation_style_assignment(psa),
  )
  let styled = @presentation.StyledItem::new("", [psa_ref], solid_ref)
  let styled_ref = ctx.add(@repository.any_entity_styled_item(styled))
  let layer = @presentation.PresentationLayerAssignment::new("1", "Layer 1", [
    solid_ref,
  ])
  let _ = ctx.add(@repository.any_entity_presentation_layer_assignment(layer))
  let md = @presentation.MechanicalDesignGeometricPresentationRepresentation::new(
    "",
    [styled_ref],
    { id: ctx.repo_ctx_id },
  )
  let _ = ctx.add(
    @repository.any_entity_mechanical_design_geometric_presentation_representation(
      md,
    ),
  )

}

///|
fn add_node_to_ctx(
  ctx : StepContext,
  node : SceneNode,
  product_defs : Array[@step.Ref],
  shape_reps : Array[@step.Ref],
) -> Unit {
  let brep_ref = compile_node_to_brep(ctx, node)
  add_solid_node_to_ctx(
    ctx,
    node,
    brep_ref,
    product_defs,
    shape_reps,
    is_csg=false,
  )
}

///|
fn add_solid_node_to_ctx(
  ctx : StepContext,
  node : SceneNode,
  solid_ref : @step.Ref,
  product_defs : Array[@step.Ref],
  shape_reps : Array[@step.Ref],
  is_csg~ : Bool,
) -> Unit {
  compile_node_geometry_and_styling(ctx, node, solid_ref)

  // Product structure for this part
  let prod_def_ref = ctx.add_product_definition(node.name)
  product_defs.push(prod_def_ref)

  // Axis placement for the part
  let origin = ctx.cartesian_point(node.tx, node.ty, node.tz)
  let (dzx, dzy, dzz) = rotate_point((0.0, 0.0, 1.0), node.rx, node.ry, node.rz)
  let (dxx, dxy, dxz) = rotate_point((1.0, 0.0, 0.0), node.rx, node.ry, node.rz)
  let dz = ctx.direction(dzx, dzy, dzz)
  let dx = ctx.direction(dxx, dxy, dxz)
  let _a2p_ref = ctx.axis2_placement_3d(origin, dz, dx)
  // Axis placement for the part
  let origin = ctx.cartesian_point(node.tx, node.ty, node.tz)
  let (dzx, dzy, dzz) = rotate_point((0.0, 0.0, 1.0), node.rx, node.ry, node.rz)
  let (dxx, dxy, dxz) = rotate_point((1.0, 0.0, 0.0), node.rx, node.ry, node.rz)
  let dz = ctx.direction(dzx, dzy, dzz)
  let dx = ctx.direction(dxx, dxy, dxz)
  let a2p_ref = ctx.axis2_placement_3d(origin, dz, dx)
  let specific_rep_ref = if is_csg {
    let csg_rep = @product.CsgShapeRepresentation::new(
      node.name + "-None",
      [a2p_ref, solid_ref],
      { id: ctx.repo_ctx_id },
    )
    ctx.add(@repository.any_entity_csg_shape_representation(csg_rep))
  } else {
    let brep_rep = @product.AdvancedBrepShapeRepresentation::new(
      node.name + "-None",
      [a2p_ref, solid_ref],
      { id: ctx.repo_ctx_id },
    )
    ctx.add(@repository.any_entity_advanced_brep_shape_representation(brep_rep))
  }
  shape_reps.push(specific_rep_ref)
  let pds = @product.ProductDefinitionShape::new("", "", prod_def_ref)
  let pds_ref = ctx.add(@repository.any_entity_product_definition_shape(pds))
  let sdr = @product.ShapeDefinitionRepresentation::new(
    pds_ref, specific_rep_ref,
  )
  let _ = ctx.add(@repository.any_entity_shape_definition_representation(sdr))

}

///|
fn compile_node_to_brep(
  ctx : StepContext,
  node : SceneNode,
  reverse? : Bool = false,
) -> @step.Ref {
  let faces = compile_node_shape(ctx, node, reverse~)
  let shell = @topology.ClosedShell::new("", faces)
  let shell_ref = ctx.add(@repository.any_entity_closed_shell(shell))
  let brep = @topology.ManifoldSolidBrep::new("", shell_ref)
  ctx.add(@repository.any_entity_manifold_solid_brep(brep))
}

///|
pub fn Design::compile(self : Design) -> @repository.Repository {
  let ctx = StepContext::new(snapping?=self.snapping)
  ctx.init_standard_context(self.name)
  let product_defs : Array[@step.Ref] = []
  let shape_reps : Array[@step.Ref] = []
  for node in self.nodes {
    match node.shape {
      Union(u) => {
        if u.nodes.length() == 0 {
          continue
        }
        if u.nodes.length() == 1 {
          add_node_to_ctx(
            ctx,
            { ..u.nodes[0], name: node.name },
            product_defs,
            shape_reps,
          )
          continue
        }
        let all_faces : Array[@step.Ref] = []
        for child in u.nodes {
          all_faces.push_iter(compile_node_shape(ctx, child).iter())
        }
        let shell = @topology.ClosedShell::new("", all_faces)
        let shell_ref = ctx.add(@repository.any_entity_closed_shell(shell))
        let brep = @topology.ManifoldSolidBrep::new("", shell_ref)
        let solid_ref = ctx.add(
          @repository.any_entity_manifold_solid_brep(brep),
        )
        add_solid_node_to_ctx(
          ctx,
          node,
          solid_ref,
          product_defs,
          shape_reps,
          is_csg=false,
        )
      }
      Difference(d) => {
        // Export base and cutters as separate products for manual boolean in CAD
        // Modern CAD systems (Plasticity/Onshape) don't support CSG import well
        add_node_to_ctx(
          ctx,
          { ..d.base, name: node.name + "-base" },
          product_defs,
          shape_reps,
        )
        let mut cutter_idx = 1
        for cutter in d.cutters {
          add_node_to_ctx(
            ctx,
            { ..cutter, name: node.name + "-cutter\{cutter_idx}" },
            product_defs,
            shape_reps,
          )
          cutter_idx = cutter_idx + 1
        }
      }
      _ => add_node_to_ctx(ctx, node, product_defs, shape_reps)
    }
  }

  // Set the header
  let file_name = self.name + ".step"
  ctx.repo = ctx.repo.set_header(default_header(file_name, self.description))
  ctx.repo
}

///|
fn compile_node_shape(
  ctx : StepContext,
  node : SceneNode,
  reverse? : Bool = false,
) -> Array[@step.Ref] {
  match node.shape {
    Cuboid(c) => compile_cuboid(ctx, node, c, reverse~)
    CalibrationChamferBlock(b) =>
      compile_calibration_chamfer_block(ctx, node, b, reverse~)
    ExtrudedProfile(e) => compile_extruded_profile(ctx, node, e, reverse~)
    SweptProfile(s) => compile_swept_profile(ctx, node, s, reverse~)
    Difference(_) => []
    _ =>
      // This should not be reached for Union shapes as they are expanded in Design::compile
      []
  }
}

///|
pub fn Design::to_step_file(self : Design) -> String {
  self.compile().to_step_file()
}

///|
// Convenience alias for examples that want `println(design.to_string())`.
pub fn Design::to_string(self : Design) -> String {
  self.to_step_file()
}

///|
pub async fn Design::write_step_file(self : Design, out_path : String?) -> Unit {
  write_text_file(self.to_step_file(), out_path)
}

///|
// Convenience alias: `design.write_step(...)`.
pub async fn Design::write_step(self : Design, out_path : String?) -> Unit {
  self.write_step_file(out_path)
}

///|
pub fn Design::add(self : Design, node : SceneNode) -> Design {
  let nodes = self.nodes.copy()
  nodes.push(node)
  Design::{ ..self, nodes, next_solid_id: self.next_solid_id + 1 }
}

///|
pub fn Design::add_iter(self : Design, nodes : Iter[SceneNode]) -> Design {
  let mut d = self
  for node in nodes {
    d = d.add(node)
  }
  d
}

///|
pub fn Design::rotate_x(self : Design, angle : Double) -> Design {
  let nodes = self.nodes.map(fn(node) {
    let (tx, ty, tz) = rotate_point(
      (node.tx, node.ty, node.tz),
      angle,
      0.0,
      0.0,
    )
    let new_node = node.rotate_x(angle)
    { ..new_node, tx, ty, tz }
  })
  { ..self, nodes, }
}

///|
pub fn Design::rotate_y(self : Design, angle : Double) -> Design {
  let nodes = self.nodes.map(fn(node) {
    let (tx, ty, tz) = rotate_point(
      (node.tx, node.ty, node.tz),
      0.0,
      angle,
      0.0,
    )
    let new_node = node.rotate_y(angle)
    { ..new_node, tx, ty, tz }
  })
  { ..self, nodes, }
}

///|
pub fn Design::rotate_z(self : Design, angle : Double) -> Design {
  let nodes = self.nodes.map(fn(node) {
    let (tx, ty, tz) = rotate_point(
      (node.tx, node.ty, node.tz),
      0.0,
      0.0,
      angle,
    )
    let new_node = node.rotate_z(angle)
    { ..new_node, tx, ty, tz }
  })
  { ..self, nodes, }
}

///|
pub fn Design::translate(
  self : Design,
  x? : Double = 0.0,
  y? : Double = 0.0,
  z? : Double = 0.0,
) -> Design {
  let nodes = self.nodes.map(fn(node) { node.translate(x~, y~, z~) })
  { ..self, nodes, }
}

///|
pub async fn write_text_file(text : String, out_path : String?) -> Unit {
  match out_path {
    None => println(text)
    Some(path) =>
      @fs.write_file(
        path,
        @encoding/utf8.encode(text),
        create=0o644,
        truncate=true,
      ) catch {
        err => println("failed to write output: \{err}")
      }
  }
}

///|
fn default_header(
  file_name : String,
  description : String,
) -> @header.HeaderSection {
  let timestamp = now_iso_timestamp()
  @header.HeaderSection::new([
    @header.HeaderEntity::FileDescription(
      @header.FileDescription::new([description], "2;1"),
    ),
    @header.HeaderEntity::FileName(
      @header.FileName::new(
        @header.StringOrDollar::Str(file_name),
        @header.StringOrDollar::Str(timestamp),
        @header.StringListOrDollar::List(["gmlewis"]),
        @header.StringListOrDollar::List(["gmlewis/step"]),
        @header.StringOrDollar::Str("gmlewis/step"),
        @header.StringOrDollar::Str("moonbit"),
        @header.StringOrDollar::Str("none"),
      ),
    ),
    @header.HeaderEntity::FileSchema(
      @header.FileSchema::new(["AUTOMOTIVE_DESIGN { 1 0 10303 214 1 1 1 1 }"]),
    ),
  ])
}

///|
fn now_iso_timestamp() -> String {
  let ms = @async.now()
  let seconds = ms / 1000L
  try
    @time.PlainDateTime::from_unix_second(seconds, 0, @time.utc_offset)
  catch {
    _ => "2025-01-01T00:00:00"
  } noraise {
    dt => dt.to_string()
  }
}
