///|
// Builder-style CAD helpers.
//
// The goal is a pleasant authoring UX for examples: build a model using a few
// high-level calls, then serialize to a valid STEP Part 21 file.

///|
pub struct Design {
  nodes : Array[SceneNode]
  next_solid_id : Int
  name : String
  description : String
}

///|
pub fn Design::new(
  name? : String = "model",
  description? : String = "generated by gmlewis/step/cad",
) -> Design {
  Design::{ nodes: [], next_solid_id: 1, name, description }
}

///|
pub fn Design::to_step_file(self : Design) -> String {
  // TODO: Implement compilation in Phase 5
  ""
}

///|
// Convenience alias for examples that want `println(design.to_string())`.
pub fn Design::to_string(self : Design) -> String {
  self.to_step_file()
}

///|
pub async fn Design::write_step_file(self : Design, out_path : String?) -> Unit {
  write_step_text(self.to_step_file(), out_path)
}

///|
// Convenience alias: `design.write_step(...)`.
pub async fn Design::write_step(self : Design, out_path : String?) -> Unit {
  self.write_step_file(out_path)
}

///|
pub fn Design::add(self : Design, node : SceneNode) -> Design {
  self.nodes.push(node)
  Design::{ ..self, next_solid_id: self.next_solid_id + 1 }
}

///|
pub async fn write_step_text(step_text : String, out_path : String?) -> Unit {
  match out_path {
    None => println(step_text)
    Some(path) =>
      @fs.write_file(
        path,
        @encoding/utf8.encode(step_text),
        create=0o644,
        truncate=true,
      ) catch {
        err => println("failed to write output: \{err}")
      }
  }
}
